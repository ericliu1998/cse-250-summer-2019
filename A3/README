For A3, I used DFS because there is a guide on how to implement it on Vicky Zheng's lecture slide.
DFS is an acronym which stands for Depth First Search. Unlike BFS (Breadth First Search), DFS goes through every combination of paths and selects the one with the shortest distance after each recursive call. DFS uses stack to keep track of visited paths so it can back track if one of the recursive calls reaches a dead end or reaches the destination. 
My program first starts off by marking the starting position as visited. Then there is a base case that checks if the starting position equals the finishing position. It will then unmark the position so that other recursive calls can go to the finishing position. If we dont unmark it, then the other recursive calls won't be able to return an alternative distance to the finishing position if there is one. After that, it will check if it can move up, down, left and right. In each of those checks that meets the condition for the position to move forward, it will make a recursive call corresponding to the conditional statement and checks if the returned number is smaller than the previous number. It then checks if none of the conditional statements passed, and returns a really big number to mark that position as a dead end. After that it unmarks the position and returns 1 + the minimum number out of the 4 recursive calls.
